from flask import Flask, render_template, request, session, jsonify
from flask_sqlalchemy import SQLAlchemy
from werkzeug.middleware.proxy_fix import ProxyFix
import requests as http_requests
from bs4 import BeautifulSoup
import google.generativeai as genai
import os
import logging
from datetime import datetime, timedelta

logging.basicConfig(level=logging.DEBUG)

app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET")
app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

class RateLimit(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    ip = db.Column(db.String(45), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

with app.app_context():
    db.create_all()

def get_rate_limit_count(ip):
    hour_ago = datetime.utcnow() - timedelta(hours=1)
    return RateLimit.query.filter(RateLimit.ip == ip, RateLimit.timestamp > hour_ago).count()

def scrape_website(url):
    try:
        response = http_requests.get(url, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        title = soup.title.string if soup.title else ""
        meta_desc = ""
        meta = soup.find("meta", attrs={"name": "description"})
        if meta and hasattr(meta, 'get'):
            meta_desc = meta.get("content", "")
            
        paragraphs = soup.find_all('p')
        meaningful_p = ""
        for p in paragraphs:
            text = p.get_text().strip()
            if len(text) > 50:
                meaningful_p = text
                break
        
        return {
            "title": title,
            "description": meta_desc,
            "paragraph": meaningful_p,
            "url": url
        }
    except Exception as e:
        return None

def generate_with_gemini(api_key, prompt):
    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel('gemini-1.5-flash-latest')
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        return f"Gemini Error: {str(e)}"

def generate_fallback(prompt):
    # Simple template-based fallback if no AI available
    return "This is a placeholder cold email generated by the free model because Hugging Face/Transformers setup is heavy for this environment."

@app.route('/')
def index():
    return render_template('dashboard.html')

@app.route('/settings')
def settings():
    return render_template('settings.html')

@app.route('/save_settings', methods=['POST'])
def save_settings():
    api_key = request.form.get('api_key')
    if api_key:
        session['gemini_api_key'] = api_key
    return jsonify({"status": "success"})

@app.route('/generate', methods=['POST'])
def generate():
    ip = request.remote_addr
    if get_rate_limit_count(ip) >= 5:
        return jsonify({"error": "Rate limit exceeded. 5 per hour."}), 429
    
    data = request.json
    website_info = scrape_website(data['url'])
    if not website_info:
        return jsonify({"error": "Failed to scrape website."}), 400
    
    prompt = f"""
    Generate 1 cold email and 2 follow-ups.
    Company Info: {website_info}
    Prospect: {data['prospect_name']}, Role: {data['prospect_role']}
    Goal: {data['email_goal']}, Tone: {data['tone']}
    Previous Email context: {data.get('prev_email', 'None')}
    Requirements: Under 120 words each, no emojis, human tone, conversational.
    """
    
    api_key = session.get('gemini_api_key')
    using_gemini = False
    if api_key:
        email_content = generate_with_gemini(api_key, prompt)
        using_gemini = True
    else:
        email_content = generate_fallback(prompt)
        
    db.session.add(RateLimit(ip=ip))
    db.session.commit()
    
    return jsonify({
        "emails": email_content,
        "model": "Gemini" if using_gemini else "Free Model",
        "sources": website_info
    })

@app.after_request
def add_header(response):
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
